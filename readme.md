# 手搓操作系统实践：从零构建属于自己的系统世界
    在探索计算机底层奥秘的道路上，我怀揣着对操作系统原理的浓厚兴趣，以及深入理解计算机系统底层运行机
制的渴望，踏上了手搓操作系统的奇妙征程。在钻研 **FreeRTOS** 与 **RT-Thread** 的经典设计理念与核心代码架构后，我以它们为灵感源泉，结合自己对实时操作系统的理解，历经无数次调试与优化，终于打造出一款简单而精巧的操作系统—— **MCOS** 。

<div align=center>
    <img src="pic/MCOS.png" alt="image" width="300" height="200">
</div>

    这个项目不仅是我对技术极致追求的体现，更是一场与代码深度对话的修行。每一行代码都是探索的脚印，每
一次调试都是成长的蜕变。通过这次实践，我不仅掌握了汇编、C语言与硬件交互的核心技术，更在 **FreeRTOS** 的内存管理、 **RT-Thread** 的模块化设计中汲取养分，对计算机系统的运行逻辑有了全新的认知，收获满满。现在，就请大家跟随我的脚步，走进 **MCOS** 这个充满挑战与惊喜的世界，一同领略它的架构与实现细节。


## 二、操作系统架构概览
    MCOS由多个关键模块协同构成，宛如精密的齿轮组，共同推动系统的高效运转。这些模块主要涵
盖启动引导、底层硬件驱动、内存管理、任务调度、中断处理等，它们各司其职，却又紧密协作，共同勾勒出操作系统的基础轮廓。接下来，让我们从系统启动的初始环节开始，逐步深入地探索各模块的精妙实现方式 。

## 三、汇编脚本：堆栈设置与系统入口跳转
### 3.1 堆栈设置
    在操作系统启动初期，汇编脚本承担着极为关键的初始化重任，其中堆栈设置堪称重中之重。我通过汇编指
令，精准地定义了堆栈的基址与边界，就像为程序的运行搭建了一个安全可靠的“储物间”，确保在程序执行过程中，局部变量、函数调用参数与返回地址都能被妥善存储。这部分代码与硬件特性紧密相连，为后续系统的稳定运行筑牢根基 。
### 3.2 系统入口跳转
    系统启动后，从启动代码到操作系统核心入口的跳转，犹如一场精心编排的接力赛交接。在汇编脚本中通过跳
转指令实现过渡。这一过程需要对CPU寄存器状态进行精准把控，如同指挥一场精密的交响乐，确保系统能够按照既定的逻辑顺利起航 。

## 四、串口初始化与信息输出
### 4.1 串口初始化
    串口作为操作系统与外界交互的重要桥梁，其初始化过程需要对硬件寄存器进行细致入微的配置。我深入研究
串口芯片手册，通过设置波特率、数据位、停止位、校验位等参数，成功开启了这座桥梁，为系统调试与信息输出铺设了可靠的通道 。
### 4.2 信息输出实现
    完成串口初始化后，通过向串口发送字符与字符串数据，在终端上准确地输出调试信息、系统状态等内容。它
不仅在开发过程中帮助我快速定位问题，如同黑夜里的明灯，也为系统运行时的监控提供了极大的便利 。

## 五、链接脚本与内存管理
### 5.1 链接脚本的作用
    链接脚本在操作系统构建过程中扮演着举足轻重的角色，它如同一位智慧的城市规划师，定义了程序各部分在
内存中的布局，包括代码段、数据段、堆栈段等。通过合理编写链接脚本，确保程序在运行时能够准确无误地访问内存资源，实现代码与数据的高效组织与管理 。
### 5.2 内存管理机制
    参考FreeRTOS中的heap4实现，我精心设计并成功实现了一套适合本操作系统的内存管理机制。该机制采用动
态内存分配策略，通过维护空闲内存块链表，如同精心打理一个仓库，实现内存的精准分配与回收，有效避免了内存碎片问题，大大提高了内存使用效率 。

## 六、上下文切换与中断处理
### 6.1 上下文切换
    为了实现多任务的并发执行，上下文切换成为不可或缺的关键功能。我通过保存与恢复任务的CPU寄存器状
态，如同记录一场演出的精彩瞬间，实现了不同任务之间的快速切换，确保每个任务在被中断后都能无缝恢复执行，从而推动系统高效有序地运行 。
### 6.2 中断处理
    中断处理是操作系统响应外部事件的核心机制。我精心设计了中断向量表，为不同类型的中断分配了专属的处
理函数，如同为每个紧急情况安排了专业的应对团队。当中断发生时，系统能够迅速做出反应，跳转到相应的中断处理程序，及时处理外部事件，保障系统的稳定性与实时性 。

## 七、定时器实现
### 7.1 硬件定时器
    硬件定时器基于CPU或外部定时器芯片，如同一个精准的机械时钟，实现精确计时功能。我通过配置定时器的
工作模式、计数初值等参数，成功启动了这个“时钟”，为系统提供了稳定的时间基准。在系统中，硬件定时器主要用于实现精确的时间延迟、周期性任务调度等功能，如同一位严谨的时间管理者 。
### 7.2 软件定时器
    软件定时器则是在硬件定时器的基础上，通过巧妙的软件算法实现的定时器功能。它更像是一个灵活的助手，
能够满足一些对精度要求相对较低的定时需求，为系统提供了更丰富、灵活的定时机制。我设计了软件定时器的管理模块，实现了定时器的创建、启动、停止与回调函数执行等功能，让这个助手能够有条不紊地工作 。

## 八、线程间同步与系统延时
### 8.1 线程间同步机制
    在多线程环境下，为了保证数据的一致性与操作的正确性，我实现了多种线程间同步机制，如互斥锁、信号量
等。这些同步机制如同交通规则，有效避免了线程之间的竞争与冲突，确保系统在多线程运行时的稳定性，让各个线程能够和谐共处 。
### 8.2 系统延时函数
    系统延时函数基于定时器实现，提供了精确的时间延迟功能。无论是任务的短暂暂停等待，还是需要按照特定
时间间隔执行的操作，都可以通过调用系统延时函数轻松实现，如同一位贴心的时间调度员 。

## 九、总结与展望
    通过本次手搓操作系统项目，我仿佛穿越了计算机底层的神秘世界，深入理解了操作系统的底层运行机制，掌
握了从硬件驱动到系统功能实现的全流程开发技术。尽管目前实现的系统功能还只是一个雏形，但每一行代码都凝聚着我探索与实践的心血。未来，我计划进一步完善系统功能，提升性能，拓展应用场景。这个项目远未结束，更多精彩的功能与优化将持续更新，敬请期待 ！ 